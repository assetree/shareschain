
package shareschain.node;

import shareschain.Constants;
import shareschain.Shareschain;
import shareschain.ShareschainExceptions;
import shareschain.permission.Role;
import shareschain.permission.RoleMapperFactory;
import shareschain.permission.SecurityToken;
import shareschain.blockchain.Transaction;
import shareschain.util.crypto.Crypto;
import shareschain.util.Logger;

import java.util.Collections;
import java.util.List;

final class GetInfo {

    /** Session key identifier */
    private static final byte[] sessionKeyId = new byte[] {(byte)0xde, (byte)0xad, (byte)0xbe, (byte)0xef};

    private GetInfo() {}

    /**
     * Process the GetInfo message and send our GetInfo message in response
     *
     * @param   node                    Node
     * @param   message                 GetInfo message
     * @return                          Always null since the response message is sent asynchronously
     */
    static NetworkMessage processRequest(NodeImpl node, NetworkMessage.GetInfoMessage message) {
        //
        // Process the node information
        //
        if (!Nodes.ignoreNodeAnnouncedAddress) {
            String announcedAddress = message.getAnnouncedAddress();
            if (announcedAddress != null) {
                announcedAddress = announcedAddress.toLowerCase().trim();
                if (!node.verifyAnnouncedAddress(announcedAddress)) {
                    Logger.logDebugMessage("GetInfo: ignoring invalid announced address for " + node.getHost());
                    String oldAnnouncedAddress = node.getAnnouncedAddress();
                    if (!node.verifyAnnouncedAddress(oldAnnouncedAddress)) {
                        Logger.logDebugMessage("GetInfo: old announced address for " + node.getHost() + " no longer valid");
                        Nodes.changeNodeAnnouncedAddress(node, null);
                    }
                    node.disconnectNode();
                    return null;
                }
                if (!announcedAddress.equals(node.getAnnouncedAddress())) {
                    Logger.logDebugMessage("GetInfo: node " + node.getHost() + " changed announced address from " + node.getAnnouncedAddress() + " to " + announcedAddress);
                    Nodes.changeNodeAnnouncedAddress(node, announcedAddress);
                }
            } else if (!node.getHost().equals(node.getAnnouncedAddress())) {
                Nodes.changeNodeAnnouncedAddress(node, null);
            }
        }
        String application = message.getApplicationName();
        if (application == null) {
            application = "?";
        }
        node.setApplication(application.trim());

        String version = message.getApplicationVersion();
        if (version == null) {
            version = "?";
        }
        if (!node.setVersion(version.trim())) {
            return null;
        }

        String platform = message.getApplicationPlatform();
        if (platform == null) {
            platform = "?";
        }
        node.setPlatform(platform.trim());

        node.setShareAddress(message.getShareAddress());

        node.setApiPort(message.getApiPort());
        node.setApiSSLPort(message.getSslPort());
        node.setDisabledAPIs(message.getDisabledAPIs());
        node.setApiServerIdleTimeout(message.getApiServerIdleTimeout());
        node.setBlockchainState(message.getBlockchainState());

        long origServices = node.getServices();
        node.setServices(message.getServices());
        if (node.getServices() != origServices) {
            Nodes.notifyListeners(node, Nodes.Event.CHANGE_SERVICES);
        }
        //
        // Authenticate the node (node must have WRITER permission)
        //
        SecurityToken securityToken = null;
        if (Constants.isPermissioned) {
            securityToken = message.getSecurityToken();
            if (securityToken == null) {
                Logger.logDebugMessage("GetInfo: No security token provided by node " + node.getHost());
                node.disconnectNode();
                return null;
            }
            long nodeId = securityToken.getNodeAccountId();
            if (!RoleMapperFactory.getRoleMapper().isUserInRole(nodeId, Role.WRITER)) {
                Logger.logDebugMessage("GetInfo: Node " + node.getHost() + " does not have WRITER permission");
                node.disconnectNode();
                return null;
            }
        }
        //
        // Indicate the connection handshake is complete.  For an inbound connection, we need
        // to send our GetInfo message.  For an outbound connection, we have already sent our
        // GetInfo message.
        //
        // The session key is generated by the node accepting the connection and is validated by
        // the node creating the connection.  The session key is encrypted using the shared secret
        // for the nodes.  This serves as an permission challenge since the session key cannot
        // be decrypted without the secret phrase associated with the public key.
        //
        if (node.isInbound()) {
            if (securityToken != null) {
                byte[] sessionKey = new byte[32];
                Crypto.getSecureRandom().nextBytes(sessionKey);
                byte[] taggedSessionKey = new byte[32 + sessionKeyId.length];
                System.arraycopy(sessionKeyId, 0, taggedSessionKey, 0, sessionKeyId.length);
                System.arraycopy(sessionKey, 0, taggedSessionKey, sessionKeyId.length, 32);
                NetworkHandler.sendGetInfoMessage(node, securityToken.getNodePublicKey(), taggedSessionKey);
                node.setSessionKey(sessionKey);
            } else {
                NetworkHandler.sendGetInfoMessage(node);
            }
        } else if (securityToken != null) {
            byte[] taggedSessionKey = securityToken.getSessionKey(Nodes.nodeSecretPhrase, securityToken.getNodePublicKey());
            if (taggedSessionKey == null) {
                Logger.logDebugMessage("GetInfo: Node " + node.getHost() + " did not provide a session key");
                node.disconnectNode();
                return null;
            }
            if (taggedSessionKey.length != sessionKeyId.length + 32) {
                Logger.logDebugMessage("GetInfo: Session key provided by " + node.getHost() + " is not valid");
                node.disconnectNode();
                return null;
            }
            for (int i=0; i<sessionKeyId.length; i++) {
                if (taggedSessionKey[i] != sessionKeyId[i]) {
                    Logger.logDebugMessage("GetInfo: Session key provided by " + node.getHost() + " is not valid");
                    node.disconnectNode();
                    return null;
                }
            }
            byte[] sessionKey = new byte[32];
            System.arraycopy(taggedSessionKey, sessionKeyId.length, sessionKey, 0, 32);
            node.setSessionKey(sessionKey);
        }
        node.handshakeComplete();
        //
        // Get the unconfirmed transactions.  This is done when a connection is established
        // to synchronize the unconfirmed transaction pools of both nodes.
        //
        Nodes.nodesService.execute(() -> {
            List<Long> unconfirmed = Shareschain.getTransactionProcessor().getAllUnconfirmedTransactionIds();
            Collections.sort(unconfirmed);
            NetworkMessage.TransactionsMessage response = (NetworkMessage.TransactionsMessage)node.sendRequest(
                    new NetworkMessage.GetUnconfirmedTransactionsMessage(unconfirmed));
            if (response == null || response.getTransactionCount() == 0) {
                return;
            }
            try {
                List<Transaction> transactions = response.getTransactions();
                List<? extends Transaction> addedTransactions = Shareschain.getTransactionProcessor().processNodeTransactions(transactions);
                TransactionsInventory.cacheTransactions(addedTransactions);
            } catch (ShareschainExceptions.ValidationExceptions | RuntimeException e) {
                node.blacklist(e);
            }
        });
        return null;
    }
}
